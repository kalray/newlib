/*
 * pwr_ctrl.coolidge-v2.dev
 * Automatically generated from registers definition files. Do not edit
 * Copyright (c) Kalray 2021.
 */

#ifndef _INCLUDED_DEVICES_PWR_CTRL_COOLIDGE_V2_DEV_
#define _INCLUDED_DEVICES_PWR_CTRL_COOLIDGE_V2_DEV_

#include "device_inttype.h"


struct mppa_pwr_ctrl_proc_config {
mppa_uint64 wakeup :1; /*[ 0: 0]reset: 0x0,behavior: [:RD, :WR],wake-up processor*/
mppa_uint64 reset_on_wakeup :1; /*[ 1: 1]reset: 0x0,behavior: [:RD, :WR],Processor FSM goes back to RESETING when going out from deep sleep*/
mppa_uint64 reserved_0:8;
mppa_uint64 wd_ack :1; /*[10:10]reset: 0x0,behavior: [:RD, :WR],Watchdog acknowledge*/
mppa_uint64 reserved_2:53;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_proc_config[(sizeof(struct mppa_pwr_ctrl_proc_config) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_proc_config as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_PROC_CONFIG_WAKEUP__SHIFT 0
#define MPPA_PWR_CTRL_PROC_CONFIG_WAKEUP__MASK 0x1ULL
#define MPPA_PWR_CTRL_PROC_CONFIG_RESET_ON_WAKEUP__SHIFT 1
#define MPPA_PWR_CTRL_PROC_CONFIG_RESET_ON_WAKEUP__MASK 0x2ULL
#define MPPA_PWR_CTRL_PROC_CONFIG_WD_ACK__SHIFT 10
#define MPPA_PWR_CTRL_PROC_CONFIG_WD_ACK__MASK 0x400ULL


/***
 * pwr_ctrl write register definition
 * This register can only be accessed by the RM
 *
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_proc_config _;
} mppa_pwr_ctrl_write_t;

/***
 * pwr_ctrl set register definition
 * Written data is considered as a mask where bits at 1 set register corresponding
 * bits. This register can only be accessed by the RM
 *
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_proc_config _;
} mppa_pwr_ctrl_set_t;

/***
 * pwr_ctrl clear register definition
 * Written data is considered as a mask where bits at 1 clear register corresponding
 * bits. This register can only be accessed by the RM
 *
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_proc_config _;
} mppa_pwr_ctrl_clear_t;

/***
 * pwr_ctrl proc_control group definition
 * Processor Power Control
 *
 * Size: 64/0x40 bytes
 */
typedef struct  {
mppa_pwr_ctrl_write_t write; /* offset: 0x0, size: 0x8 */
mppa_uint8 unused0[8];
mppa_pwr_ctrl_set_t set; /* offset: 0x10, size: 0x8 */
mppa_uint8 unused1[8];
mppa_pwr_ctrl_clear_t clear; /* offset: 0x20, size: 0x8 */
mppa_uint8 unused2[24];
} mppa_pwr_ctrl_proc_control_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_proc_control_t[(sizeof(mppa_pwr_ctrl_proc_control_t) == 64)*2-1];// If this fails, then the size of mppa_pwr_ctrl_proc_control_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
struct mppa_pwr_ctrl_proc_status {
mppa_uint64 wd :1; /*[ 0: 0]reset: 0x0,behavior: [:RD],*/
mppa_uint64 idle :2; /*[ 2: 1]reset: 0x2,behavior: [:RD],*/
mppa_uint64 fsm :2; /*[ 4: 3]reset: 0x0,behavior: [:RD],*/
mppa_uint64 reserved_1:59;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_proc_status[(sizeof(struct mppa_pwr_ctrl_proc_status) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_proc_status as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_PROC_STATUS_WD__SHIFT 0
#define MPPA_PWR_CTRL_PROC_STATUS_WD__MASK 0x1ULL
#define MPPA_PWR_CTRL_PROC_STATUS_IDLE__SHIFT 1
#define MPPA_PWR_CTRL_PROC_STATUS_IDLE__MASK 0x6ULL
#define MPPA_PWR_CTRL_PROC_STATUS_FSM__SHIFT 3
#define MPPA_PWR_CTRL_PROC_STATUS_FSM__MASK 0x18ULL


/***
 * pwr_ctrl proc_sts register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x4
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_proc_status _;
} mppa_pwr_ctrl_proc_sts_t;

/***
 * pwr_ctrl proc_status group definition
 * Processor Power Control
 *
 * Size: 16/0x10 bytes
 */
typedef struct  {
mppa_pwr_ctrl_proc_sts_t proc_sts; /* offset: 0x0, size: 0x8 */
mppa_uint8 unused0[8];
} mppa_pwr_ctrl_proc_status_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_proc_status_t[(sizeof(mppa_pwr_ctrl_proc_status_t) == 16)*2-1];// If this fails, then the size of mppa_pwr_ctrl_proc_status_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
struct mppa_pwr_ctrl_core {
union {
struct {
mppa_uint64 pe :16; /*[15: 0]reset: 0x0,behavior: [:RD, :WR],*/
mppa_uint64 reserved_1:48;
};
struct {
mppa_uint64 pe_0 :1;
mppa_uint64 pe_1 :1;
mppa_uint64 pe_2 :1;
mppa_uint64 pe_3 :1;
mppa_uint64 pe_4 :1;
mppa_uint64 pe_5 :1;
mppa_uint64 pe_6 :1;
mppa_uint64 pe_7 :1;
mppa_uint64 pe_8 :1;
mppa_uint64 pe_9 :1;
mppa_uint64 pe_10 :1;
mppa_uint64 pe_11 :1;
mppa_uint64 pe_12 :1;
mppa_uint64 pe_13 :1;
mppa_uint64 pe_14 :1;
mppa_uint64 pe_15 :1;
mppa_uint64 :48;
};
};
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_core[(sizeof(struct mppa_pwr_ctrl_core) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_core as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_CORE_PE__SHIFT 0
#define MPPA_PWR_CTRL_CORE_PE__MASK 0xffffULL


#define MPPA_PWR_CTRL_CORE_PE_0__SHIFT 0
#define MPPA_PWR_CTRL_CORE_PE_0__MASK 0x1ULL
#define MPPA_PWR_CTRL_CORE_PE_1__SHIFT 1
#define MPPA_PWR_CTRL_CORE_PE_1__MASK 0x2ULL
#define MPPA_PWR_CTRL_CORE_PE_2__SHIFT 2
#define MPPA_PWR_CTRL_CORE_PE_2__MASK 0x4ULL
#define MPPA_PWR_CTRL_CORE_PE_3__SHIFT 3
#define MPPA_PWR_CTRL_CORE_PE_3__MASK 0x8ULL
#define MPPA_PWR_CTRL_CORE_PE_4__SHIFT 4
#define MPPA_PWR_CTRL_CORE_PE_4__MASK 0x10ULL
#define MPPA_PWR_CTRL_CORE_PE_5__SHIFT 5
#define MPPA_PWR_CTRL_CORE_PE_5__MASK 0x20ULL
#define MPPA_PWR_CTRL_CORE_PE_6__SHIFT 6
#define MPPA_PWR_CTRL_CORE_PE_6__MASK 0x40ULL
#define MPPA_PWR_CTRL_CORE_PE_7__SHIFT 7
#define MPPA_PWR_CTRL_CORE_PE_7__MASK 0x80ULL
#define MPPA_PWR_CTRL_CORE_PE_8__SHIFT 8
#define MPPA_PWR_CTRL_CORE_PE_8__MASK 0x100ULL
#define MPPA_PWR_CTRL_CORE_PE_9__SHIFT 9
#define MPPA_PWR_CTRL_CORE_PE_9__MASK 0x200ULL
#define MPPA_PWR_CTRL_CORE_PE_10__SHIFT 10
#define MPPA_PWR_CTRL_CORE_PE_10__MASK 0x400ULL
#define MPPA_PWR_CTRL_CORE_PE_11__SHIFT 11
#define MPPA_PWR_CTRL_CORE_PE_11__MASK 0x800ULL
#define MPPA_PWR_CTRL_CORE_PE_12__SHIFT 12
#define MPPA_PWR_CTRL_CORE_PE_12__MASK 0x1000ULL
#define MPPA_PWR_CTRL_CORE_PE_13__SHIFT 13
#define MPPA_PWR_CTRL_CORE_PE_13__MASK 0x2000ULL
#define MPPA_PWR_CTRL_CORE_PE_14__SHIFT 14
#define MPPA_PWR_CTRL_CORE_PE_14__MASK 0x4000ULL
#define MPPA_PWR_CTRL_CORE_PE_15__SHIFT 15
#define MPPA_PWR_CTRL_CORE_PE_15__MASK 0x8000ULL


/***
 * pwr_ctrl vector_proc_write register definition
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_core _;
} mppa_pwr_ctrl_vector_proc_write_t;

/***
 * pwr_ctrl vector_proc_set register definition
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_core _;
} mppa_pwr_ctrl_vector_proc_set_t;

/***
 * pwr_ctrl vector_proc_clear register definition
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_core _;
} mppa_pwr_ctrl_vector_proc_clear_t;

/***
 * pwr_ctrl write_set_clear group definition
 * Write, Set and Clear registers group
 *
 * Size: 64/0x40 bytes
 */
typedef struct  {
mppa_pwr_ctrl_vector_proc_write_t write; /* offset: 0x0, size: 0x8 */
mppa_uint8 unused0[8];
mppa_pwr_ctrl_vector_proc_set_t set; /* offset: 0x10, size: 0x8 */
mppa_uint8 unused1[8];
mppa_pwr_ctrl_vector_proc_clear_t clear; /* offset: 0x20, size: 0x8 */
mppa_uint8 unused2[24];
} mppa_pwr_ctrl_write_set_clear_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_write_set_clear_t[(sizeof(mppa_pwr_ctrl_write_set_clear_t) == 64)*2-1];// If this fails, then the size of mppa_pwr_ctrl_write_set_clear_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
/***
 * pwr_ctrl vector_proc_control group definition
 * Global PEs Power Control
 *
 * Size: 192/0xC0 bytes
 */
typedef struct  {
mppa_pwr_ctrl_write_set_clear_t wup; /* offset: 0x0, size: 0x40 */
mppa_pwr_ctrl_write_set_clear_t reset_on_wakeup; /* offset: 0x40, size: 0x40 */
mppa_pwr_ctrl_write_set_clear_t wd_ack; /* offset: 0x80, size: 0x40 */
} mppa_pwr_ctrl_vector_proc_control_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_vector_proc_control_t[(sizeof(mppa_pwr_ctrl_vector_proc_control_t) == 192)*2-1];// If this fails, then the size of mppa_pwr_ctrl_vector_proc_control_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
/***
 * pwr_ctrl vec_proc_status register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_core _;
} mppa_pwr_ctrl_vec_proc_status_t;

struct mppa_pwr_ctrl_core_2b_idle {
union {
struct {
mppa_uint64 pe :32; /*[31: 0]reset: 0x2,behavior: [:RD],*/
mppa_uint64 reserved_1:32;
};
struct {
mppa_uint64 pe_0 :2;
mppa_uint64 pe_1 :2;
mppa_uint64 pe_2 :2;
mppa_uint64 pe_3 :2;
mppa_uint64 pe_4 :2;
mppa_uint64 pe_5 :2;
mppa_uint64 pe_6 :2;
mppa_uint64 pe_7 :2;
mppa_uint64 pe_8 :2;
mppa_uint64 pe_9 :2;
mppa_uint64 pe_10 :2;
mppa_uint64 pe_11 :2;
mppa_uint64 pe_12 :2;
mppa_uint64 pe_13 :2;
mppa_uint64 pe_14 :2;
mppa_uint64 pe_15 :2;
mppa_uint64 :32;
};
};
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_core_2b_idle[(sizeof(struct mppa_pwr_ctrl_core_2b_idle) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_core_2b_idle as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE__SHIFT 0
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE__MASK 0xffffffffULL


#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_0__SHIFT 0
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_0__MASK 0x3ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_1__SHIFT 2
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_1__MASK 0xcULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_2__SHIFT 4
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_2__MASK 0x30ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_3__SHIFT 6
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_3__MASK 0xc0ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_4__SHIFT 8
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_4__MASK 0x300ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_5__SHIFT 10
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_5__MASK 0xc00ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_6__SHIFT 12
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_6__MASK 0x3000ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_7__SHIFT 14
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_7__MASK 0xc000ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_8__SHIFT 16
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_8__MASK 0x30000ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_9__SHIFT 18
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_9__MASK 0xc0000ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_10__SHIFT 20
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_10__MASK 0x300000ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_11__SHIFT 22
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_11__MASK 0xc00000ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_12__SHIFT 24
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_12__MASK 0x3000000ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_13__SHIFT 26
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_13__MASK 0xc000000ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_14__SHIFT 28
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_14__MASK 0x30000000ULL
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_15__SHIFT 30
#define MPPA_PWR_CTRL_CORE_2B_IDLE_PE_15__MASK 0xc0000000ULL


/***
 * pwr_ctrl vec_2bits_proc_status_idle register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0xAAAAAAAA
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_core_2b_idle _;
} mppa_pwr_ctrl_vec_2bits_proc_status_idle_t;

struct mppa_pwr_ctrl_core_2b {
union {
struct {
mppa_uint64 pe :32; /*[31: 0]reset: 0x0,behavior: [:RD],*/
mppa_uint64 rm :2; /*[33:32]reset: 0x2,behavior: [:RD],*/
mppa_uint64 reserved_1:30;
};
struct {
mppa_uint64 pe_0 :2;
mppa_uint64 pe_1 :2;
mppa_uint64 pe_2 :2;
mppa_uint64 pe_3 :2;
mppa_uint64 pe_4 :2;
mppa_uint64 pe_5 :2;
mppa_uint64 pe_6 :2;
mppa_uint64 pe_7 :2;
mppa_uint64 pe_8 :2;
mppa_uint64 pe_9 :2;
mppa_uint64 pe_10 :2;
mppa_uint64 pe_11 :2;
mppa_uint64 pe_12 :2;
mppa_uint64 pe_13 :2;
mppa_uint64 pe_14 :2;
mppa_uint64 pe_15 :2;
mppa_uint64 :2; /* rm */ /*[33:32]reset: 0x2,behavior: [:RD],*/
mppa_uint64 :30;
};
};
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_core_2b[(sizeof(struct mppa_pwr_ctrl_core_2b) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_core_2b as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_CORE_2B_PE__SHIFT 0
#define MPPA_PWR_CTRL_CORE_2B_PE__MASK 0xffffffffULL
#define MPPA_PWR_CTRL_CORE_2B_RM__SHIFT 32
#define MPPA_PWR_CTRL_CORE_2B_RM__MASK 0x300000000ULL


#define MPPA_PWR_CTRL_CORE_2B_PE_0__SHIFT 0
#define MPPA_PWR_CTRL_CORE_2B_PE_0__MASK 0x3ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_1__SHIFT 2
#define MPPA_PWR_CTRL_CORE_2B_PE_1__MASK 0xcULL
#define MPPA_PWR_CTRL_CORE_2B_PE_2__SHIFT 4
#define MPPA_PWR_CTRL_CORE_2B_PE_2__MASK 0x30ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_3__SHIFT 6
#define MPPA_PWR_CTRL_CORE_2B_PE_3__MASK 0xc0ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_4__SHIFT 8
#define MPPA_PWR_CTRL_CORE_2B_PE_4__MASK 0x300ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_5__SHIFT 10
#define MPPA_PWR_CTRL_CORE_2B_PE_5__MASK 0xc00ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_6__SHIFT 12
#define MPPA_PWR_CTRL_CORE_2B_PE_6__MASK 0x3000ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_7__SHIFT 14
#define MPPA_PWR_CTRL_CORE_2B_PE_7__MASK 0xc000ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_8__SHIFT 16
#define MPPA_PWR_CTRL_CORE_2B_PE_8__MASK 0x30000ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_9__SHIFT 18
#define MPPA_PWR_CTRL_CORE_2B_PE_9__MASK 0xc0000ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_10__SHIFT 20
#define MPPA_PWR_CTRL_CORE_2B_PE_10__MASK 0x300000ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_11__SHIFT 22
#define MPPA_PWR_CTRL_CORE_2B_PE_11__MASK 0xc00000ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_12__SHIFT 24
#define MPPA_PWR_CTRL_CORE_2B_PE_12__MASK 0x3000000ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_13__SHIFT 26
#define MPPA_PWR_CTRL_CORE_2B_PE_13__MASK 0xc000000ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_14__SHIFT 28
#define MPPA_PWR_CTRL_CORE_2B_PE_14__MASK 0x30000000ULL
#define MPPA_PWR_CTRL_CORE_2B_PE_15__SHIFT 30
#define MPPA_PWR_CTRL_CORE_2B_PE_15__MASK 0xc0000000ULL


/***
 * pwr_ctrl vec_2bits_proc_status register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x200000000
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_core_2b _;
} mppa_pwr_ctrl_vec_2bits_proc_status_t;

/***
 * pwr_ctrl vector_proc_status group definition
 * Global PEs Power Control
 *
 * Size: 40/0x28 bytes
 */
typedef struct  {
mppa_pwr_ctrl_vec_proc_status_t wd; /* offset: 0x0, size: 0x8 */
mppa_uint8 unused0[8];
mppa_pwr_ctrl_vec_2bits_proc_status_idle_t idle; /* offset: 0x10, size: 0x8 */
mppa_uint8 unused1[8];
mppa_pwr_ctrl_vec_2bits_proc_status_t fsm; /* offset: 0x20, size: 0x8 */
} mppa_pwr_ctrl_vector_proc_status_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_vector_proc_status_t[(sizeof(mppa_pwr_ctrl_vector_proc_status_t) == 40)*2-1];// If this fails, then the size of mppa_pwr_ctrl_vector_proc_status_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
struct mppa_pwr_ctrl_pc {
mppa_uint64 pc :32; /*[31: 0]reset: 0x0,behavior: [:RD, :WR],PE Reset PC*/
mppa_uint64 reserved_1:32;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_pc[(sizeof(struct mppa_pwr_ctrl_pc) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_pc as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_PC_PC__SHIFT 0
#define MPPA_PWR_CTRL_PC_PC__MASK 0xffffffffULL


/***
 * pwr_ctrl pe_reset_pc register definition
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_pc _;
} mppa_pwr_ctrl_pe_reset_pc_t;

struct mppa_pwr_ctrl_global_status {
mppa_uint64 rm_wup :1; /*[ 0: 0]reset: 0x0,behavior: [:RD],wake-up bit from bootmode to RM*/
mppa_uint64 res1 :1; /*[ 1: 1]reset: 0x1,behavior: [:R1],Top reset*/
mppa_uint64 clk_en :1; /*[ 2: 2]reset: 0x1,behavior: [:RD],Kernel clock enable*/
mppa_uint64 shuf_dis :1; /*[ 3: 3]reset: 0x0,behavior: [:RD],Shuffling disable*/
mppa_uint64 noc_idle :1; /*[ 4: 4]reset: 0x1,behavior: [:RD],All DMA RX and TX channel are clear*/
mppa_uint64 dbg_fifo_idle :1; /*[ 5: 5]reset: 0x1,behavior: [:RD],Debug message fifo empty*/
mppa_uint64 watchdog :1; /*[ 6: 6]reset: 0x1,behavior: [:RD],Watchdog fire*/
mppa_uint64 reserved_1:57;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_global_status[(sizeof(struct mppa_pwr_ctrl_global_status) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_global_status as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_GLOBAL_STATUS_RM_WUP__SHIFT 0
#define MPPA_PWR_CTRL_GLOBAL_STATUS_RM_WUP__MASK 0x1ULL
#define MPPA_PWR_CTRL_GLOBAL_STATUS_RES1__SHIFT 1
#define MPPA_PWR_CTRL_GLOBAL_STATUS_RES1__MASK 0x2ULL
#define MPPA_PWR_CTRL_GLOBAL_STATUS_CLK_EN__SHIFT 2
#define MPPA_PWR_CTRL_GLOBAL_STATUS_CLK_EN__MASK 0x4ULL
#define MPPA_PWR_CTRL_GLOBAL_STATUS_SHUF_DIS__SHIFT 3
#define MPPA_PWR_CTRL_GLOBAL_STATUS_SHUF_DIS__MASK 0x8ULL
#define MPPA_PWR_CTRL_GLOBAL_STATUS_NOC_IDLE__SHIFT 4
#define MPPA_PWR_CTRL_GLOBAL_STATUS_NOC_IDLE__MASK 0x10ULL
#define MPPA_PWR_CTRL_GLOBAL_STATUS_DBG_FIFO_IDLE__SHIFT 5
#define MPPA_PWR_CTRL_GLOBAL_STATUS_DBG_FIFO_IDLE__MASK 0x20ULL
#define MPPA_PWR_CTRL_GLOBAL_STATUS_WATCHDOG__SHIFT 6
#define MPPA_PWR_CTRL_GLOBAL_STATUS_WATCHDOG__MASK 0x40ULL


/***
 * pwr_ctrl global_status register definition
 *
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x76
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_global_status _;
} mppa_pwr_ctrl_global_status_t;

struct mppa_pwr_ctrl_ecc_status {
mppa_uint64 secc :16; /*[15: 0]reset: 0x0,behavior: [:RD],single ecc error status per bank*/
mppa_uint64 decc :16; /*[31:16]reset: 0x0,behavior: [:RD],double ecc error status per bank*/
mppa_uint64 reserved_1:32;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_ecc_status[(sizeof(struct mppa_pwr_ctrl_ecc_status) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_ecc_status as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_ECC_STATUS_SECC__SHIFT 0
#define MPPA_PWR_CTRL_ECC_STATUS_SECC__MASK 0xffffULL
#define MPPA_PWR_CTRL_ECC_STATUS_DECC__SHIFT 16
#define MPPA_PWR_CTRL_ECC_STATUS_DECC__MASK 0xffff0000ULL


/***
 * pwr_ctrl ecc_status register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_ecc_status _;
} mppa_pwr_ctrl_ecc_status_t;

/***
 * pwr_ctrl ecc_status_clear register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:CUSTOM],
 * PE: ker => [:CUSTOM],
 * PE: usr => [:CUSTOM],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_ecc_status _;
} mppa_pwr_ctrl_ecc_status_clear_t;

struct mppa_pwr_ctrl_secure_status_crypto0_nonsecure {
mppa_uint64 present :1; /*[ 0: 0]reset: 0x1,behavior: [:RD],Crypto Acc 0 present in non-secure world*/
mppa_uint64 reserved_1:63;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_secure_status_crypto0_nonsecure[(sizeof(struct mppa_pwr_ctrl_secure_status_crypto0_nonsecure) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_secure_status_crypto0_nonsecure as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_SECURE_STATUS_CRYPTO0_NONSECURE_PRESENT__SHIFT 0
#define MPPA_PWR_CTRL_SECURE_STATUS_CRYPTO0_NONSECURE_PRESENT__MASK 0x1ULL


/***
 * pwr_ctrl crypto0_nonsecure register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x1
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_secure_status_crypto0_nonsecure _;
} mppa_pwr_ctrl_crypto0_nonsecure_t;

struct mppa_pwr_ctrl_secure_status_crypto0_secure {
mppa_uint64 present :1; /*[ 0: 0]reset: 0x0,behavior: [:RD],Crypto Acc 0 present in secure world*/
mppa_uint64 reserved_1:63;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_secure_status_crypto0_secure[(sizeof(struct mppa_pwr_ctrl_secure_status_crypto0_secure) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_secure_status_crypto0_secure as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_SECURE_STATUS_CRYPTO0_SECURE_PRESENT__SHIFT 0
#define MPPA_PWR_CTRL_SECURE_STATUS_CRYPTO0_SECURE_PRESENT__MASK 0x1ULL


/***
 * pwr_ctrl crypto0_secure register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_secure_status_crypto0_secure _;
} mppa_pwr_ctrl_crypto0_secure_t;

struct mppa_pwr_ctrl_secure_status_crypto1_nonsecure {
mppa_uint64 present :1; /*[ 0: 0]reset: 0x1,behavior: [:RD],Crypto Acc 0 present in non-secure world*/
mppa_uint64 reserved_1:63;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_secure_status_crypto1_nonsecure[(sizeof(struct mppa_pwr_ctrl_secure_status_crypto1_nonsecure) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_secure_status_crypto1_nonsecure as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_SECURE_STATUS_CRYPTO1_NONSECURE_PRESENT__SHIFT 0
#define MPPA_PWR_CTRL_SECURE_STATUS_CRYPTO1_NONSECURE_PRESENT__MASK 0x1ULL


/***
 * pwr_ctrl crypto1_nonsecure register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x1
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_secure_status_crypto1_nonsecure _;
} mppa_pwr_ctrl_crypto1_nonsecure_t;

struct mppa_pwr_ctrl_secure_status_crypto1_secure {
mppa_uint64 present :1; /*[ 0: 0]reset: 0x0,behavior: [:RD],Crypto Acc 0 present in secure world*/
mppa_uint64 reserved_1:63;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_secure_status_crypto1_secure[(sizeof(struct mppa_pwr_ctrl_secure_status_crypto1_secure) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_secure_status_crypto1_secure as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_SECURE_STATUS_CRYPTO1_SECURE_PRESENT__SHIFT 0
#define MPPA_PWR_CTRL_SECURE_STATUS_CRYPTO1_SECURE_PRESENT__MASK 0x1ULL


/***
 * pwr_ctrl crypto1_secure register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_secure_status_crypto1_secure _;
} mppa_pwr_ctrl_crypto1_secure_t;

/***
 * pwr_ctrl secure_status group definition
 * Secure status
 *
 * Size: 32/0x20 bytes
 */
typedef struct  {
mppa_pwr_ctrl_crypto0_nonsecure_t crypto0_nonsecure; /* offset: 0x0, size: 0x8 */
mppa_pwr_ctrl_crypto0_secure_t crypto0_secure; /* offset: 0x8, size: 0x8 */
mppa_pwr_ctrl_crypto1_nonsecure_t crypto1_nonsecure; /* offset: 0x10, size: 0x8 */
mppa_pwr_ctrl_crypto1_secure_t crypto1_secure; /* offset: 0x18, size: 0x8 */
} mppa_pwr_ctrl_secure_status_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_secure_status_t[(sizeof(mppa_pwr_ctrl_secure_status_t) == 32)*2-1];// If this fails, then the size of mppa_pwr_ctrl_secure_status_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
struct mppa_pwr_ctrl_v_dsu_time_stamp {
mppa_uint64 timestamp :64; /*[63: 0]reset: 0x0,behavior: [:RD],DSU Timestamp*/
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_v_dsu_time_stamp[(sizeof(struct mppa_pwr_ctrl_v_dsu_time_stamp) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_v_dsu_time_stamp as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_V_DSU_TIME_STAMP_TIMESTAMP__SHIFT 0
#define MPPA_PWR_CTRL_V_DSU_TIME_STAMP_TIMESTAMP__MASK 0xffffffffffffffffULL


/***
 * pwr_ctrl dsu_timestamp register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 8 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
mppa_uint32 word[2];
struct mppa_pwr_ctrl_v_dsu_time_stamp _;
} mppa_pwr_ctrl_dsu_timestamp_t;

struct mppa_pwr_ctrl_sp_control {
mppa_uint64 start :1; /*[ 0: 0]reset: 0x0,behavior: [:RD, :WR],SMEM Profiling Start:

Once this bit is set to 1 by the software, all SMEM Profiling Counters will start counting.
This bit is automatically cleared by hardware when it is 1 and a SMEM Profiling Counter whose spc_control.sp_ie bit is set overflows (i.e. increments by one or more and wraps from 0xFFFFFFFF FFFFFF.. to 0x00000000 000000..) When this happens:

- an interrupt (pulse) is issued by the SMEM Profiling module

- all SMEM Profiling Counters stop counting and their current value remains frozen

- sp_status.ie_num is set to the relevant value

If a SPC overflows while its spc_control.sp_ie bit is not set, nothing happens: the overflowing SPC just wraps around silently to 0x00000000 000000.. and continues counting. The other SPCs continue counting too, and no interrupt is sent

SMEM Profiling Counters will start counting again as soon as the software re-sets sp_control.start.*/
mppa_uint64 reserved_1:63;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_sp_control[(sizeof(struct mppa_pwr_ctrl_sp_control) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_sp_control as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_SP_CONTROL_START__SHIFT 0
#define MPPA_PWR_CTRL_SP_CONTROL_START__MASK 0x1ULL


/***
 * pwr_ctrl sp_control register definition
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 8 bytes (min access size = 8 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
struct mppa_pwr_ctrl_sp_control _;
} mppa_pwr_ctrl_sp_control_t;

struct mppa_pwr_ctrl_sp_status {
mppa_uint64 ie_num :5; /*[ 4: 0]reset: 0x0,behavior: [:RD],SMEM Profiling Interrupt Event Number:

When an SMEM Profiling Counter whose spc_control.sp_ie bit is set overflows, this field is set equal to the number of this SPC.*/
mppa_uint64 reserved_1:59;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_sp_status[(sizeof(struct mppa_pwr_ctrl_sp_status) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_sp_status as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_SP_STATUS_IE_NUM__SHIFT 0
#define MPPA_PWR_CTRL_SP_STATUS_IE_NUM__MASK 0x1fULL


/***
 * pwr_ctrl sp_status register definition
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 8 bytes (min access size = 8 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
struct mppa_pwr_ctrl_sp_status _;
} mppa_pwr_ctrl_sp_status_t;

struct mppa_pwr_ctrl_spc_control {
mppa_uint16 sp_code_sel :5; /*[ 4: 0]reset: 0x0,behavior: [:RD, :WR],SMEM Profiling Counter Code Selection:

SMEM Profiling Counter counts the event selected by this field.

This counting is per Bank or Global: when spc_control.sp_global is 1, the events to all SMEM Banks are summed; otherwise, only events to spc_control.sp_bank_sel SMEM Bank are counted.

Supported values are:

- 0x0 : RE    : Reset: SPC is set to 0

- 0x1 : SE    : Stop: SPC stops counting

- 0x2 : SCC   : SMEM Clock Cycle: SPC is incremented every clock cycle

- 0x4 : TCME  : TCM Event: SPC is incremented every time an access hits SMEM Bank's TCM

- 0x5 : TCMLE : TCM Load Event: SPC is incremented every time a load access hits SMEM Bank's TCM

- 0x6 : TCMDLE: TCM Doucle Load Event: SPC is incremented every time a double load access hits SMEM Bank's TCM

- 0x8 : L2CE  : L2 Cache Event: SPC is incremented every time an access hits SMEM Bank's L2 Cache

- 0x9 : L2CLE : L2 Cache Load Event: SPC is incremented every time a load access hits SMEM Bank's L2 Cache

- 0xA : SHTE  : Shoot-Through Event: SPC is incremented every time a shoot-through access hits SMEM Bank's L2 Cache

- 0xB : SHTLE : Shoot-Through Load Event: SPC is incremented every time a shoot-through load access hits SMEM Bank's L2 Cache

- 0xC : SBSC  : SMEM Bank Stall Cycle: SPC is incremented every time SMEM Bank is stalled

- 0xD : SBMSC : SMEM Bank Memory Stall Cycle: SPC is incremented every time SMEM Bank is stalled due to ECC correction, atomic operation or non 64-bit aligned access

- 0x10: L2RE  : L2 Cache Refill Event: SPC is incremented every time SMEM Bank sent a Refill request outside of the Cluster

- 0x11: L2WBE : L2 Cache Write-Back Event: SPC is incremented every time SMEM Bank sent a non-null Write-Back request outside of the Cluster

- 0x14: L2CMF : L2 Cache Maintenance Flush Event: SPC is incremented every time an L2 Cache Maintenance Flush operation hits SMEM Bank

- 0x15: L2CMI : L2 Cache Maintenance Invalidate Event: SPC is incremented every time an L2 Cache Maintenance Invalidate operation hits SMEM Bank

- 0x16: L2CMP : L2 Cache Maintenance Purge Event: SPC is incremented every time an L2 Cache Maintenance Purge operation hits SMEM Bank

- 0x18: RL2CMF: Remote L2 Cache Maintenance Flush Event: SPC is incremented every time an L2 Cache Maintenance Flush operation from DSU's L2 Remote module hits SMEM Bank

- 0x19: RL2CMI: Remote L2 Cache Maintenance Invalidate Event: SPC is incremented every time an L2 Cache Maintenance Invalidate operation from DSU's L2 Remote module hits SMEM Bank

- 0x1A: RL2CMP: Remote L2 Cache Maintenance Purge Event: SPC is incremented every time an L2 Cache Maintenance Purge operation from DSU's L2 Remote module hits SMEM Bank

All other codes are reserved.*/
mppa_uint16 reserved_0:3;
mppa_uint16 sp_bank_sel :4; /*[11: 8]reset: 0x0,behavior: [:RD, :WR],SMEM Profiling Counter Bank Selection:

SMEM Profiling Counter counts the events that occurs in the SMEM Bank selected by this field. Supported values are:

- 0x0-0xf: Bank 0-15

Though, this field is only relevant when spc_control.sp_global is 0.*/
mppa_uint16 sp_global :1; /*[12:12]reset: 0x0,behavior: [:RD, :WR],SMEM Profiling Counter Global:

If set to 1, SMEM Profiling Counter counts the events that occurs in all the SMEM Banks (i.e. events are summed per SMEM Bank). In this case bank_sel field is irrelevant.*/
mppa_uint16 reserved_1:2;
mppa_uint16 sp_ie :1; /*[15:15]reset: 0x0,behavior: [:RD, :WR],SMEM Profiling Counter Interrupt Enable:

If set to 1, this bit enables interrupt generation if SMEM Profiling Counter overflows.*/
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_spc_control[(sizeof(struct mppa_pwr_ctrl_spc_control) == 2)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_spc_control as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_SPC_CONTROL_SP_CODE_SEL__SHIFT 0
#define MPPA_PWR_CTRL_SPC_CONTROL_SP_CODE_SEL__MASK 0x1fUL
#define MPPA_PWR_CTRL_SPC_CONTROL_SP_BANK_SEL__SHIFT 8
#define MPPA_PWR_CTRL_SPC_CONTROL_SP_BANK_SEL__MASK 0xf00UL
#define MPPA_PWR_CTRL_SPC_CONTROL_SP_GLOBAL__SHIFT 12
#define MPPA_PWR_CTRL_SPC_CONTROL_SP_GLOBAL__MASK 0x1000UL
#define MPPA_PWR_CTRL_SPC_CONTROL_SP_IE__SHIFT 15
#define MPPA_PWR_CTRL_SPC_CONTROL_SP_IE__MASK 0x8000UL


/***
 * pwr_ctrl spc_control register definition
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 2 bytes (min access size = 2 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint16 reg;
mppa_uint16 hword;
struct mppa_pwr_ctrl_spc_control _;
} mppa_pwr_ctrl_spc_control_t;

struct mppa_pwr_ctrl_spc_reg {
mppa_uint64 spc_reg :64; /*[63: 0]reset: 0x0,behavior: [:RD, :WR],SMEM Profiling Counter:

SMEM Profiling Counter are updated according to common sp_control and dedicated spc_control registers.

This Counter is Read/Write: this allows the software to set this counter to a chosen value in order to trigger this SPC overflow for instance.*/
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_spc_reg[(sizeof(struct mppa_pwr_ctrl_spc_reg) == 8)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_spc_reg as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_SPC_REG_SPC_REG__SHIFT 0
#define MPPA_PWR_CTRL_SPC_REG_SPC_REG__MASK 0xffffffffffffffffULL


/***
 * pwr_ctrl spc_reg register definition
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 8 bytes (min access size = 8 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint64 reg;
mppa_uint64 dword;
struct mppa_pwr_ctrl_spc_reg _;
} mppa_pwr_ctrl_spc_reg_t;

/***
 * pwr_ctrl smem_profiling group definition
 * SMEM Profiling Group of Registers
 *
 * Size: 256/0x100 bytes
 */
#define MPPA_PWR_CTRL_SMEM_PROFILING_SPC_CONTROL_NUMBER 24
#define MPPA_PWR_CTRL_SMEM_PROFILING_SPC_REG_NUMBER 24
typedef struct  {
mppa_pwr_ctrl_sp_control_t sp_control; /* offset: 0x0, size: 0x8 */
mppa_pwr_ctrl_sp_status_t sp_status; /* offset: 0x8, size: 0x8 */
mppa_pwr_ctrl_spc_control_t spc_control[24]; /* offset: 0x10, size: 0x30 ( /!\ this is a 16bits register*/
mppa_pwr_ctrl_spc_reg_t spc_reg[24]; /* offset: 0x40, size: 0xC0 ( /!\ this is a 64bits register*/
} mppa_pwr_ctrl_smem_profiling_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_smem_profiling_t[(sizeof(mppa_pwr_ctrl_smem_profiling_t) == 256)*2-1];// If this fails, then the size of mppa_pwr_ctrl_smem_profiling_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
struct mppa_pwr_ctrl_ring_level {
mppa_uint32 ring_level :2; /*[ 1: 0]reset: 0x3,behavior: [:RD, :WR],Protection ring level, value is relative to current initiator ring level*/
mppa_uint32 data_lock :1; /*[ 2: 2]reset: 0x0,behavior: [:RD, :WR],If set all protected registers are RO*/
mppa_uint32 lock :1; /*[ 3: 3]reset: 0x0,behavior: [:RD, :WR],Auto-lock. RO if it is set, only cleared on the next reset*/
mppa_uint32 reserved_1:28;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_ring_level[(sizeof(struct mppa_pwr_ctrl_ring_level) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_ring_level as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_RING_LEVEL_RING_LEVEL__SHIFT 0
#define MPPA_PWR_CTRL_RING_LEVEL_RING_LEVEL__MASK 0x3UL
#define MPPA_PWR_CTRL_RING_LEVEL_DATA_LOCK__SHIFT 2
#define MPPA_PWR_CTRL_RING_LEVEL_DATA_LOCK__MASK 0x4UL
#define MPPA_PWR_CTRL_RING_LEVEL_LOCK__SHIFT 3
#define MPPA_PWR_CTRL_RING_LEVEL_LOCK__MASK 0x8UL


/***
 * pwr_ctrl ring_config register definition
 * Ring Protection Config
 *
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0x3
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_ring_level _;
} mppa_pwr_ctrl_ring_config_t;

struct mppa_pwr_ctrl_ring_level_abs {
mppa_uint32 ring_level :2; /*[ 1: 0]reset: 0x3,behavior: [:RD],Absolute value of protection ring level*/
mppa_uint32 reserved_1:30;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_ring_level_abs[(sizeof(struct mppa_pwr_ctrl_ring_level_abs) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_ring_level_abs as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_RING_LEVEL_ABS_RING_LEVEL__SHIFT 0
#define MPPA_PWR_CTRL_RING_LEVEL_ABS_RING_LEVEL__MASK 0x3UL


/***
 * pwr_ctrl ring_level_abs_value register definition
 * Absolute value of protection ring level
 *
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0x3
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_ring_level_abs _;
} mppa_pwr_ctrl_ring_level_abs_value_t;

struct mppa_pwr_ctrl_config {
mppa_uint32 two_steps_auth :1; /*[ 0: 0]reset: 0x0,behavior: [:RD, :WR],Enable two-steps authentication. RO if 'lock' bit is set*/
mppa_uint32 wr_dis :1; /*[ 1: 1]reset: 0x0,behavior: [:RD, :WR],Disable writes in whole regbank. RO if 'lock' bit is set*/
mppa_uint32 lock :1; /*[ 2: 2]reset: 0x0,behavior: [:RD, :WR],Auto-lock. RO if it is set, only cleared on the next reset*/
mppa_uint32 reserved_1:29;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_config[(sizeof(struct mppa_pwr_ctrl_config) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_config as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_CONFIG_TWO_STEPS_AUTH__SHIFT 0
#define MPPA_PWR_CTRL_CONFIG_TWO_STEPS_AUTH__MASK 0x1UL
#define MPPA_PWR_CTRL_CONFIG_WR_DIS__SHIFT 1
#define MPPA_PWR_CTRL_CONFIG_WR_DIS__MASK 0x2UL
#define MPPA_PWR_CTRL_CONFIG_LOCK__SHIFT 2
#define MPPA_PWR_CTRL_CONFIG_LOCK__MASK 0x4UL


/***
 * pwr_ctrl init_config register definition
 * Initiator Protection Config
 *
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_config _;
} mppa_pwr_ctrl_init_config_t;

struct mppa_pwr_ctrl_allow_rd {
mppa_uint32 read_mask_enable :32; /*[31: 0]reset: 0xFFFFFFFF,behavior: [:RD, :WR],Mask of allowed initiators for read accesses. RO if 'INITIATOR_PROTECT_CONFIG.lock' bit is set*/
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_allow_rd[(sizeof(struct mppa_pwr_ctrl_allow_rd) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_allow_rd as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_ALLOW_RD_READ_MASK_ENABLE__SHIFT 0
#define MPPA_PWR_CTRL_ALLOW_RD_READ_MASK_ENABLE__MASK 0xffffffffUL


/***
 * pwr_ctrl allow_ld register definition
 * Allowed Initiators for read accesses
 *
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0xFFFFFFFF
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_allow_rd _;
} mppa_pwr_ctrl_allow_ld_t;

struct mppa_pwr_ctrl_allow_wr {
mppa_uint32 write_mask_enable :32; /*[31: 0]reset: 0xFFFFFFFF,behavior: [:RD, :WR],Mask of allowed initiators for write accesses. RO if 'INITIATOR_PROTECT_CONFIG.lock' bit is set*/
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_allow_wr[(sizeof(struct mppa_pwr_ctrl_allow_wr) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_allow_wr as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_ALLOW_WR_WRITE_MASK_ENABLE__SHIFT 0
#define MPPA_PWR_CTRL_ALLOW_WR_WRITE_MASK_ENABLE__MASK 0xffffffffUL


/***
 * pwr_ctrl allow_st register definition
 * Allowed Initiators for write accesses
 *
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0xFFFFFFFF
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_allow_wr _;
} mppa_pwr_ctrl_allow_st_t;

struct mppa_pwr_ctrl_enabled_mask {
mppa_uint32 write_mask_subscribers :32; /*[31: 0]reset: 0x0,behavior: [:RD],Mask of enabled initiators
Bits description:
[0..15]: PEs,
16: RM,
17: DSU,
18: Crypto DMA0,
19: Crypto DMA1,
20: AXI Write,
21: AXI Read,
22: DMA Tx,
23: DMA Rx*/
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_enabled_mask[(sizeof(struct mppa_pwr_ctrl_enabled_mask) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_enabled_mask as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_ENABLED_MASK_WRITE_MASK_SUBSCRIBERS__SHIFT 0
#define MPPA_PWR_CTRL_ENABLED_MASK_WRITE_MASK_SUBSCRIBERS__MASK 0xffffffffUL


/***
 * pwr_ctrl subscribe_write register definition
 * Mask of enabled initiators
 *
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_enabled_mask _;
} mppa_pwr_ctrl_subscribe_write_t;

struct mppa_pwr_ctrl_subscribe {
mppa_uint32 magic_value :32; /*[31: 0]reset: 0x0,behavior: [:WR],Write 'magic value' <TDB> to subscribe.*/
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_subscribe[(sizeof(struct mppa_pwr_ctrl_subscribe) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_subscribe as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_SUBSCRIBE_MAGIC_VALUE__SHIFT 0
#define MPPA_PWR_CTRL_SUBSCRIBE_MAGIC_VALUE__MASK 0xffffffffUL


/***
 * pwr_ctrl subscribe register definition
 * Initiator subscribe register
 *
 * Permissions:
 * RM: ker => [:WR],
 * RM: usr => [:WR],
 * PE: ker => [:WR],
 * PE: usr => [:WR],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_subscribe _;
} mppa_pwr_ctrl_subscribe_t;

/***
 * pwr_ctrl protect group definition
 *
 * Size: 28/0x1C bytes
 */
typedef struct  {
mppa_pwr_ctrl_init_config_t config; /* offset: 0x0, size: 0x4 */
mppa_pwr_ctrl_allow_ld_t read_mask_enable; /* offset: 0x4, size: 0x4 */
mppa_pwr_ctrl_allow_st_t write_mask_enable; /* offset: 0x8, size: 0x4 */
mppa_pwr_ctrl_subscribe_write_t write_mask_subscribers; /* offset: 0xC, size: 0x4 */
mppa_pwr_ctrl_subscribe_t subscribe_write; /* offset: 0x10, size: 0x4 */
mppa_pwr_ctrl_ring_config_t ring_level_config; /* offset: 0x14, size: 0x4 */
mppa_pwr_ctrl_ring_level_abs_value_t ring_level_abs_value; /* offset: 0x18, size: 0x4 */
} mppa_pwr_ctrl_protect_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_protect_t[(sizeof(mppa_pwr_ctrl_protect_t) == 28)*2-1];// If this fails, then the size of mppa_pwr_ctrl_protect_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
struct mppa_pwr_ctrl_debug_addr_low {
mppa_uint32 addr_31_0 :32; /*[31: 0]reset: 0x0,behavior: [:RD],Address in error (low part)*/
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_debug_addr_low[(sizeof(struct mppa_pwr_ctrl_debug_addr_low) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_debug_addr_low as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_DEBUG_ADDR_LOW_ADDR_31_0__SHIFT 0
#define MPPA_PWR_CTRL_DEBUG_ADDR_LOW_ADDR_31_0__MASK 0xffffffffUL


/***
 * pwr_ctrl addr_31_0 register definition
 * In case of register access error, contains the low part of address
 *
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_debug_addr_low _;
} mppa_pwr_ctrl_addr_31_0_t;

struct mppa_pwr_ctrl_debug_addr_high {
mppa_uint32 addr_63_32 :32; /*[31: 0]reset: 0x0,behavior: [:RD],Address in error (high part)*/
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_debug_addr_high[(sizeof(struct mppa_pwr_ctrl_debug_addr_high) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_debug_addr_high as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_DEBUG_ADDR_HIGH_ADDR_63_32__SHIFT 0
#define MPPA_PWR_CTRL_DEBUG_ADDR_HIGH_ADDR_63_32__MASK 0xffffffffUL


/***
 * pwr_ctrl addr_63_32 register definition
 * In case of register access error, contains the high part of address
 *
 * Permissions:
 * RM: ker => [:RD],
 * RM: usr => [:RD],
 * PE: ker => [:RD],
 * PE: usr => [:RD],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_debug_addr_high _;
} mppa_pwr_ctrl_addr_63_32_t;

struct mppa_pwr_ctrl_debug_err_status {
mppa_uint32 error :1; /*[ 0: 0]reset: 0x0,behavior: [:RD, :WR],Set if an error is detected.
This bit is sticky, so the register is frozen up to this bit is clear.*/
mppa_uint32 error_type :13; /*[13: 1]reset: 0x0,behavior: [:RD, :WR],Error type
[1] : Initiator : unauthorised read,
[2] : Initiator : unauthorised write,
[3] : Initiator : two step authorisation,
[4] : Initiator : write disable,
[5] : Decoder   : decode,
[6] : Decoder   : access,
[7] : Decoder   : size,
[8] : Decoder   : ring,
[9] : Decoder   : lock,
[10]: Decoder   : atomic,
[11]: Ring      : overflow,
[12]: Register  : parity on read,
[13]: Register  : parity on the fly*/
mppa_uint32 reserved_0:2;
mppa_uint32 ring_level :2; /*[17:16]reset: 0x0,behavior: [:RD, :WR],Ring Level*/
mppa_uint32 write :1; /*[18:18]reset: 0x0,behavior: [:RD, :WR],'1' for read, '0' for write*/
mppa_uint32 size :3; /*[21:19]reset: 0x0,behavior: [:RD, :WR],Size*/
mppa_uint32 initiator :5; /*[26:22]reset: 0x0,behavior: [:RD, :WR],Initiator number*/
mppa_uint32 reserved_2:5;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_debug_err_status[(sizeof(struct mppa_pwr_ctrl_debug_err_status) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_debug_err_status as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_ERROR__SHIFT 0
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_ERROR__MASK 0x1UL
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_ERROR_TYPE__SHIFT 1
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_ERROR_TYPE__MASK 0x3ffeUL
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_RING_LEVEL__SHIFT 16
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_RING_LEVEL__MASK 0x30000UL
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_WRITE__SHIFT 18
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_WRITE__MASK 0x40000UL
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_SIZE__SHIFT 19
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_SIZE__MASK 0x380000UL
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_INITIATOR__SHIFT 22
#define MPPA_PWR_CTRL_DEBUG_ERR_STATUS_INITIATOR__MASK 0x7c00000UL


/***
 * pwr_ctrl err_status register definition
 * In case of register access error, contains the high part of address
 *
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_debug_err_status _;
} mppa_pwr_ctrl_err_status_t;

struct mppa_pwr_ctrl_error_injection {
mppa_uint32 enable :1; /*[ 0: 0]reset: 0x0,behavior: [:RD, :WR],Enable the injection of error*/
mppa_uint32 error_type :4; /*[ 4: 1]reset: 0x0,behavior: [:RD, :WR],Error type to inject:
[1] : Initiator : unauthorised read,
[2] : Initiator : unauthorised write,
[3] : Initiator : two step authorisation,
[4] : Initiator : write disable,
[5] : Decoder   : decode,
[6] : Decoder   : access,
[7] : Decoder   : size,
[8] : Decoder   : ring,
[9] : Decoder   : lock,
[10]: Decoder   : atomic,
[11]: Ring      : overflow,
[12]: Register  : parity on read,
[13]: Register  : parity on the fly*/
mppa_uint32 reserved_1:27;
};

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_struct_mppa_pwr_ctrl_error_injection[(sizeof(struct mppa_pwr_ctrl_error_injection) == 4)*2-1];// If this fails, then the size of struct mppa_pwr_ctrl_error_injection as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#define MPPA_PWR_CTRL_ERROR_INJECTION_ENABLE__SHIFT 0
#define MPPA_PWR_CTRL_ERROR_INJECTION_ENABLE__MASK 0x1UL
#define MPPA_PWR_CTRL_ERROR_INJECTION_ERROR_TYPE__SHIFT 1
#define MPPA_PWR_CTRL_ERROR_INJECTION_ERROR_TYPE__MASK 0x1eUL


/***
 * pwr_ctrl error_injection register definition
 * Poisoning register
 *
 * Permissions:
 * RM: ker => [:RD, :WR],
 * RM: usr => [:RD, :WR],
 * PE: ker => [:RD, :WR],
 * PE: usr => [:RD, :WR],
 * Size: 4 bytes (min access size = 4 bytes)
 * Reset value: 0x0
 */
typedef union {
mppa_uint32 reg;
mppa_uint32 word;
struct mppa_pwr_ctrl_error_injection _;
} mppa_pwr_ctrl_error_injection_t;

/***
 * pwr_ctrl debug_reg group definition
 *
 * Size: 24/0x18 bytes
 */
typedef struct  {
mppa_pwr_ctrl_addr_31_0_t addr_31_0; /* offset: 0x0, size: 0x4 */
mppa_pwr_ctrl_addr_63_32_t addr_63_32; /* offset: 0x4, size: 0x4 */
mppa_pwr_ctrl_err_status_t err_status; /* offset: 0x8, size: 0x4 */
mppa_pwr_ctrl_error_injection_t error_injection; /* offset: 0xC, size: 0x4 */
mppa_pwr_ctrl_ring_config_t dbg_ring_level_config; /* offset: 0x10, size: 0x4 */
mppa_pwr_ctrl_ring_level_abs_value_t dbg_ring_level_abs_val; /* offset: 0x14, size: 0x4 */
} mppa_pwr_ctrl_debug_reg_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_debug_reg_t[(sizeof(mppa_pwr_ctrl_debug_reg_t) == 24)*2-1];// If this fails, then the size of mppa_pwr_ctrl_debug_reg_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
/***
 * pwr_ctrl device definition
 * Cluster Power Controller
 *
 * Size: 20408/0x4FB8 bytes
 */
#define MPPA_PWR_CTRL_PE_CONTROL_NUMBER 16
#define MPPA_PWR_CTRL_PE_STATUS_NUMBER 16
typedef struct  {
mppa_pwr_ctrl_proc_control_t pe_control[16]; /* offset: 0x0, size: 0x400 */
mppa_pwr_ctrl_proc_status_t pe_status[16]; /* offset: 0x400, size: 0x100 */
mppa_uint8 unused0[2816];
mppa_pwr_ctrl_vector_proc_control_t vector_proc_control; /* offset: 0x1000, size: 0xC0 */
mppa_uint8 unused1[64];
mppa_pwr_ctrl_vector_proc_status_t vector_proc_status; /* offset: 0x1100, size: 0x28 */
mppa_uint8 unused2[3800];
mppa_pwr_ctrl_pe_reset_pc_t pe_reset_pc; /* offset: 0x2000, size: 0x8 */
mppa_uint8 unused3[8312];
mppa_pwr_ctrl_global_status_t global_status; /* offset: 0x4080, size: 0x8 */
mppa_uint8 unused4[184];
mppa_pwr_ctrl_ecc_status_t ecc_status; /* offset: 0x4140, size: 0x8 */
mppa_uint8 unused5[8];
mppa_pwr_ctrl_ecc_status_clear_t ecc_status_clear; /* offset: 0x4150, size: 0x8 */
mppa_uint8 unused6[8];
mppa_pwr_ctrl_secure_status_t secure_status; /* offset: 0x4160, size: 0x20 */
mppa_pwr_ctrl_dsu_timestamp_t dsu_timestamp; /* offset: 0x4180, size: 0x8 */
mppa_uint8 unused7[632];
mppa_pwr_ctrl_smem_profiling_t smem_profiling; /* offset: 0x4400, size: 0x100 */
mppa_uint8 unused8[2680];
mppa_pwr_ctrl_ring_config_t ring_level_config; /* offset: 0x4F78, size: 0x4 */
mppa_pwr_ctrl_ring_level_abs_value_t ring_level_abs_val; /* offset: 0x4F7C, size: 0x4 */
mppa_pwr_ctrl_protect_t initiator_protect; /* offset: 0x4F80, size: 0x1C */
mppa_pwr_ctrl_debug_reg_t debug_regs; /* offset: 0x4F9C, size: 0x18 */
mppa_uint8 unused9[4];
} mppa_pwr_ctrl_t;

#ifndef KVX_DISABLE_TYPECHECK
typedef char assertion_for_mppa_pwr_ctrl_t[(sizeof(mppa_pwr_ctrl_t) == 20408)*2-1];// If this fails, then the size of mppa_pwr_ctrl_t as created by the compiler does not match the hardware size.

#endif /* KVX_DISABLE_TYPECHECK */
#endif // _INCLUDED_DEVICES_PWR_CTRL_COOLIDGE_V2_DEV_

/* -*- Mode: C; c-basic-offset: 2 -*- */
/* vim:set ft=c sw=2 cindent: */
